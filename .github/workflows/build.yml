name: Build Minecraft Capture

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  release:
    types: [ created ]

jobs:
  build:
    runs-on: windows-latest
    
    strategy:
      matrix:
        architecture: [x64, x86]
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v1.3
      
    - name: Setup Visual Studio environment
      uses: ilammy/msvc-dev-cmd@v1
      with:
        arch: ${{ matrix.architecture }}
        
    - name: Create build directory
      run: mkdir build -Force
      
    - name: Create source file
      shell: powershell
      run: |
        $sourceCode = @"
        #ifndef WIN32_LEAN_AND_MEAN
        #define WIN32_LEAN_AND_MEAN
        #endif

        #include <windows.h>
        #include <objbase.h>
        #include <gdiplus.h>

        #ifndef _WINSOCKAPI_
        #define _WINSOCKAPI_
        #endif

        #include <winsock2.h>
        #include <ws2tcpip.h>
        #include <stdio.h>
        #include <thread>
        #include <vector>
        #include <string>
        #include <algorithm>

        #pragma comment(lib, "gdiplus.lib")
        #pragma comment(lib, "ws2_32.lib")
        #pragma comment(lib, "ole32.lib")

        using namespace Gdiplus;

        class SimpleMinecraftCapture {
        private:
            HWND m_minecraftWindow;
            SOCKET m_serverSocket;
            volatile bool m_running;
            GdiplusStartupInput gdiplusStartupInput;
            ULONG_PTR gdiplusToken;

        public:
            SimpleMinecraftCapture() : m_minecraftWindow(NULL), m_serverSocket(INVALID_SOCKET), m_running(false) {}
            bool Initialize() {
                if (GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL) != Ok) {
                    printf("GDI+ initialization failed\n");
                    return false;
                }
                
                WSADATA wsaData;
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != 0) {
                    printf("WSAStartup failed\n");
                    return false;
                }
                
                m_minecraftWindow = FindMinecraftWindow();
                if (!m_minecraftWindow) {
                    printf("Minecraft window not found!\n");
                    printf("Please ensure Minecraft Bedrock Edition is running\n");
                    return false;
                }
                
                char windowTitle[256];
                GetWindowTextA(m_minecraftWindow, windowTitle, sizeof(windowTitle));
                printf("Found window: %s\n", windowTitle);
                
                return true;
            }
            
            void StartCapture() {
                m_running = true;
                
                std::thread serverThread([this]() {
                    StartHTTPServer();
                });
                
                std::thread captureThread([this]() {
                    CaptureLoop();
                });
                
                printf("Server started!\n");
                printf("Open http://localhost:8080 in your browser\n");
                printf("Press any key to stop...\n");
                
                getchar();
                
                m_running = false;
                
                if (m_serverSocket != INVALID_SOCKET) {
                    closesocket(m_serverSocket);
                }
                
                if (serverThread.joinable()) {
                    serverThread.join();
                }
                if (captureThread.joinable()) {
                    captureThread.join();
                }
            }
            
            ~SimpleMinecraftCapture() {
                m_running = false;
                if (m_serverSocket != INVALID_SOCKET) {
                    closesocket(m_serverSocket);
                }
                WSACleanup();
                GdiplusShutdown(gdiplusToken);
            }

        private:
            std::vector<BYTE> m_latestFrame;
            HWND FindMinecraftWindow() {
                HWND hwnd = NULL;
                
                const char* titles[] = {
                    "Minecraft",
                    "Minecraft Bedrock",
                    "Minecraft for Windows 10",
                    "Minecraft: Bedrock Edition"
                };
                
                for (const char* title : titles) {
                    hwnd = FindWindowA(NULL, title);
                    if (hwnd) {
                        printf("Found window by title: %s\n", title);
                        break;
                    }
                }
                
                if (!hwnd) {
                    printf("Enumerating all windows...\n");
                    EnumWindows([](HWND hwnd, LPARAM lParam) -> BOOL {
                        char title[256];
                        GetWindowTextA(hwnd, title, sizeof(title));
                        
                        if (strlen(title) > 0) {
                            std::string titleStr(title);
                            std::transform(titleStr.begin(), titleStr.end(), titleStr.begin(), ::tolower);
                            
                            if (titleStr.find("minecraft") != std::string::npos) {
                                printf("Found possible Minecraft window: %s\n", title);
                                *((HWND*)lParam) = hwnd;
                                return FALSE;
                            }
                        }
                        return TRUE;
                    }, (LPARAM)&hwnd);
                }
                
                return hwnd;
            }
            
            void CaptureLoop() {
                printf("Starting capture loop...\n");
                while (m_running) {
                    try {
                        CaptureFrame();
                        Sleep(33);
                    } catch (...) {
                        printf("Error capturing frame\n");
                        Sleep(100);
                    }
                }
                printf("Capture loop ended\n");
            }
            
            void CaptureFrame() {
                if (!IsWindow(m_minecraftWindow)) {
                    printf("Minecraft window closed\n");
                    m_running = false;
                    return;
                }
                
                RECT windowRect;
                if (!GetClientRect(m_minecraftWindow, &windowRect)) {
                    return;
                }
                
                int width = windowRect.right - windowRect.left;
                int height = windowRect.bottom - windowRect.top;
                
                if (width <= 0 || height <= 0) {
                    return;
                }
                
                HDC windowDC = GetDC(m_minecraftWindow);
                if (!windowDC) {
                    return;
                }
                
                HDC memDC = CreateCompatibleDC(windowDC);
                if (!memDC) {
                    ReleaseDC(m_minecraftWindow, windowDC);
                    return;
                }
                
                HBITMAP memBitmap = CreateCompatibleBitmap(windowDC, width, height);
                if (!memBitmap) {
                    DeleteDC(memDC);
                    ReleaseDC(m_minecraftWindow, windowDC);
                    return;
                }
                
                HGDIOBJ oldBitmap = SelectObject(memDC, memBitmap);
                
                if (BitBlt(memDC, 0, 0, width, height, windowDC, 0, 0, SRCCOPY)) {
                    Bitmap bitmap(memBitmap, NULL);
                    
                    if (bitmap.GetLastStatus() == Ok) {
                        IStream* stream = NULL;
                        if (SUCCEEDED(CreateStreamOnHGlobal(NULL, TRUE, &stream))) {
                            CLSID jpegClsid;
                            if (GetEncoderClsid(L"image/jpeg", &jpegClsid) >= 0) {
                                EncoderParameters encoderParams;
                                encoderParams.Count = 1;
                                encoderParams.Parameter[0].Guid = EncoderQuality;
                                encoderParams.Parameter[0].Type = EncoderParameterValueTypeLong;
                                encoderParams.Parameter[0].NumberOfValues = 1;
                                ULONG quality = 70;
                                encoderParams.Parameter[0].Value = &quality;
                                
                                if (bitmap.Save(stream, &jpegClsid, &encoderParams) == Ok) {
                                    HGLOBAL hGlobal;
                                    if (SUCCEEDED(GetHGlobalFromStream(stream, &hGlobal))) {
                                        DWORD size = GlobalSize(hGlobal);
                                        BYTE* data = (BYTE*)GlobalLock(hGlobal);
                                        
                                        if (data && size > 0) {
                                            m_latestFrame.assign(data, data + size);
                                        }
                                        
                                        if (data) {
                                            GlobalUnlock(hGlobal);
                                        }
                                    }
                                }
                            }
                            stream->Release();
                        }
                    }
                }
                
                SelectObject(memDC, oldBitmap);
                DeleteObject(memBitmap);
                DeleteDC(memDC);
                ReleaseDC(m_minecraftWindow, windowDC);
            }
            
            void StartHTTPServer() {
                printf("Starting HTTP server...\n");
                
                m_serverSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (m_serverSocket == INVALID_SOCKET) {
                    printf("Failed to create socket: %d\n", WSAGetLastError());
                    return;
                }
                
                int optval = 1;
                setsockopt(m_serverSocket, SOL_SOCKET, SO_REUSEADDR, (char*)&optval, sizeof(optval));
                
                sockaddr_in serverAddr;
                serverAddr.sin_family = AF_INET;
                serverAddr.sin_addr.s_addr = INADDR_ANY;
                serverAddr.sin_port = htons(8080);
                
                if (bind(m_serverSocket, (sockaddr*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) {
                    printf("Failed to bind port: %d\n", WSAGetLastError());
                    return;
                }
                
                if (listen(m_serverSocket, 5) == SOCKET_ERROR) {
                    printf("Failed to listen: %d\n", WSAGetLastError());
                    return;
                }
                
                printf("HTTP server listening on port 8080...\n");
                
                while (m_running) {
                    sockaddr_in clientAddr;
                    int clientAddrSize = sizeof(clientAddr);
                    SOCKET clientSocket = accept(m_serverSocket, (sockaddr*)&clientAddr, &clientAddrSize);
                    
                    if (clientSocket != INVALID_SOCKET) {
                        std::thread([this, clientSocket]() {
                            HandleClient(clientSocket);
                        }).detach();
                    } else if (m_running) {
                        printf("Accept failed: %d\n", WSAGetLastError());
                        Sleep(100);
                    }
                }
                
                printf("HTTP server stopped\n");
            }
            
            void HandleClient(SOCKET clientSocket) {
                char buffer[2048];
                int bytesReceived = recv(clientSocket, buffer, sizeof(buffer) - 1, 0);
                if (bytesReceived > 0) {
                    buffer[bytesReceived] = '\0';
                    
                    std::string request(buffer);
                    if (request.find("GET /image") != std::string::npos) {
                        SendImage(clientSocket);
                    } else {
                        SendHTML(clientSocket);
                    }
                }
                
                closesocket(clientSocket);
            }
            
            void SendHTML(SOCKET clientSocket) {
                std::string html = "HTTP/1.1 200 OK\r\nContent-Type: text/html; charset=utf-8\r\nConnection: close\r\n\r\n<!DOCTYPE html><html><head><title>Minecraft Live View</title><meta charset=\"utf-8\"><style>body{margin:0;background:#1a1a1a;display:flex;justify-content:center;align-items:center;height:100vh;font-family:'Segoe UI',Arial,sans-serif;overflow:hidden}#gameFrame{max-width:95vw;max-height:95vh;border:3px solid #4CAF50;border-radius:8px;box-shadow:0 0 20px rgba(76,175,80,0.3)}.info{position:absolute;top:20px;left:20px;color:#4CAF50;background:rgba(0,0,0,0.8);padding:15px;border-radius:8px;border:1px solid #4CAF50}.status{color:#81C784;margin-top:5px}.loading{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#4CAF50;font-size:18px}</style></head><body><div class=\"info\"><h3 style=\"margin:0 0 10px 0\">ðŸŽ® Minecraft Live View</h3><div class=\"status\">Status: <span id=\"status\">Connecting...</span></div><div class=\"status\">Refresh Rate: ~30fps</div></div><div class=\"loading\" id=\"loading\">Loading...</div><img id=\"gameFrame\" src=\"/image\" alt=\"Minecraft View\" style=\"display:none;\"><script>const img=document.getElementById('gameFrame');const loading=document.getElementById('loading');const status=document.getElementById('status');let isLoaded=false;function updateImage(){const newImg=new Image();newImg.onload=function(){img.src=newImg.src;if(!isLoaded){loading.style.display='none';img.style.display='block';status.textContent='Running';isLoaded=true}};newImg.onerror=function(){status.textContent='Connection Error'};newImg.src='/image?'+new Date().getTime()}updateImage();setInterval(updateImage,33);img.onerror=function(){status.textContent='Image Load Failed'}</script></body></html>";
                
                send(clientSocket, html.c_str(), (int)html.length(), 0);
            }
            
            void SendImage(SOCKET clientSocket) {
                if (m_latestFrame.empty()) {
                    std::string response = "HTTP/1.1 404 Not Found\r\nContent-Length: 0\r\nConnection: close\r\n\r\n";
                    send(clientSocket, response.c_str(), (int)response.length(), 0);
                    return;
                }
                
                std::string header = "HTTP/1.1 200 OK\r\n";
                header += "Content-Type: image/jpeg\r\n";
                header += "Content-Length: " + std::to_string(m_latestFrame.size()) + "\r\n";
                header += "Cache-Control: no-cache\r\n";
                header += "Connection: close\r\n\r\n";
                
                send(clientSocket, header.c_str(), (int)header.length(), 0);
                send(clientSocket, (const char*)m_latestFrame.data(), (int)m_latestFrame.size(), 0);
            }
            
            int GetEncoderClsid(const WCHAR* format, CLSID* pClsid) {
                UINT num = 0;
                UINT size = 0;
                
                ImageCodecInfo* pImageCodecInfo = NULL;
                GetImageEncodersSize(&num, &size);
                if (size == 0) return -1;
                
                pImageCodecInfo = (ImageCodecInfo*)(malloc(size));
                if (pImageCodecInfo == NULL) return -1;
                
                GetImageEncoders(num, size, pImageCodecInfo);
                
                for (UINT j = 0; j < num; ++j) {
                    if (wcscmp(pImageCodecInfo[j].MimeType, format) == 0) {
                        *pClsid = pImageCodecInfo[j].Clsid;
                        free(pImageCodecInfo);
                        return j;
                    }
                }
                
                free(pImageCodecInfo);
                return -1;
            }
        };

        int main() {
            printf("=================================\n");
            printf("Minecraft Bedrock Screen Capture\n");
            printf("=================================\n");
            printf("Please ensure Minecraft Bedrock Edition is running\n\n");
            
            SimpleMinecraftCapture capture;
            
            if (!capture.Initialize()) {
                printf("\nInitialization failed!\n");
                printf("Please check:\n");
                printf("1. Minecraft Bedrock Edition is running\n");
                printf("2. Window is visible (not minimized)\n");
                printf("3. Program has sufficient permissions\n");
                printf("\nPress any key to exit...\n");
                getchar();
                return -1;
            }
            
            capture.StartCapture();
            return 0;
        }
        "@
        $sourceCode | Out-File -FilePath "SimpleMinecraftCapture.cpp" -Encoding UTF8
        
    - name: Compile application
      run: |
        cl /EHsc /O2 /MT /DWIN32_LEAN_AND_MEAN SimpleMinecraftCapture.cpp gdiplus.lib ws2_32.lib ole32.lib gdi32.lib user32.lib /Fe:build/MinecraftCapture-${{ matrix.architecture }}.exe
        
    - name: Verify build
      run: |
        if (Test-Path "build/MinecraftCapture-${{ matrix.architecture }}.exe") {
          Write-Host "Build successful for ${{ matrix.architecture }}"
          Get-ChildItem build/MinecraftCapture-${{ matrix.architecture }}.exe | Select-Object Name, Length, LastWriteTime
        } else {
          Write-Error "Build failed for ${{ matrix.architecture }}"
          exit 1
        }
      shell: powershell
      
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: minecraft-capture-${{ matrix.architecture }}
        path: build/MinecraftCapture-${{ matrix.architecture }}.exe
        
    - name: Upload to release (if release)
      if: github.event_name == 'release'
      uses: softprops/action-gh-release@v1
      with:
        files: build/MinecraftCapture-${{ matrix.architecture }}.exe
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
